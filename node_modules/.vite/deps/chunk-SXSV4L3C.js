import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/natural-compare-lite/index.js
var require_natural_compare_lite = __commonJS({
  "node_modules/natural-compare-lite/index.js"(exports, module) {
    var naturalCompare2 = function(a, b) {
      var i, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
      function getCode(str, pos, code) {
        if (code) {
          for (i = pos; code = getCode(str, i), code < 76 && code > 65; ) ++i;
          return +str.slice(pos - 1, i);
        }
        code = alphabet && alphabet.indexOf(str.charAt(pos));
        return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63;
      }
      if ((a += "") != (b += "")) for (; codeB; ) {
        codeA = getCode(a, posA++);
        codeB = getCode(b, posB++);
        if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
          codeA = getCode(a, posA, posA);
          codeB = getCode(b, posB, posA = i);
          posB = i;
        }
        if (codeA != codeB) return codeA < codeB ? -1 : 1;
      }
      return 0;
    };
    try {
      module.exports = naturalCompare2;
    } catch (e) {
      String.naturalCompare = naturalCompare2;
    }
  }
});

// node_modules/hex-rgb/index.js
var hexCharacters = "a-f\\d";
var match3or4Hex = `#?[${hexCharacters}]{3}[${hexCharacters}]?`;
var match6or8Hex = `#?[${hexCharacters}]{6}([${hexCharacters}]{2})?`;
var nonHexChars = new RegExp(`[^#${hexCharacters}]`, "gi");
var validHexSize = new RegExp(`^${match3or4Hex}$|^${match6or8Hex}$`, "i");
function hexRgb(hex, options = {}) {
  if (typeof hex !== "string" || nonHexChars.test(hex) || !validHexSize.test(hex)) {
    throw new TypeError("Expected a valid hex string");
  }
  hex = hex.replace(/^#/, "");
  let alphaFromHex = 1;
  if (hex.length === 8) {
    alphaFromHex = Number.parseInt(hex.slice(6, 8), 16) / 255;
    hex = hex.slice(0, 6);
  }
  if (hex.length === 4) {
    alphaFromHex = Number.parseInt(hex.slice(3, 4).repeat(2), 16) / 255;
    hex = hex.slice(0, 3);
  }
  if (hex.length === 3) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  const number = Number.parseInt(hex, 16);
  const red = number >> 16;
  const green = number >> 8 & 255;
  const blue = number & 255;
  const alpha = typeof options.alpha === "number" ? options.alpha : alphaFromHex;
  if (options.format === "array") {
    return [red, green, blue, alpha];
  }
  if (options.format === "css") {
    const alphaString = alpha === 1 ? "" : ` / ${Number((alpha * 100).toFixed(2))}%`;
    return `rgb(${red} ${green} ${blue}${alphaString})`;
  }
  return { red, green, blue, alpha };
}

// node_modules/@create-figma-plugin/utilities/lib/color/convert-hex-color-to-rgb-color.js
function convertHexColorToRgbColor(hexColor) {
  if (hexColor.length !== 3 && hexColor.length !== 6) {
    return null;
  }
  try {
    const { red, green, blue } = hexRgb(hexColor);
    return {
      b: blue / 255,
      g: green / 255,
      r: red / 255
    };
  } catch {
    return null;
  }
}

// node_modules/@create-figma-plugin/utilities/lib/color/private/named-colors.js
var NAMED_COLORS = {
  aliceblue: "F0F8FF",
  antiquewhite: "FAEBD7",
  aqua: "00FFFF",
  aquamarine: "7FFFD4",
  azure: "F0FFFF",
  beige: "F5F5DC",
  bisque: "FFE4C4",
  black: "000000",
  blanchedalmond: "FFEBCD",
  blue: "0000FF",
  blueviolet: "8A2BE2",
  brown: "A52A2A",
  burlywood: "DEB887",
  cadetblue: "5F9EA0",
  chartreuse: "7FFF00",
  chocolate: "D2691E",
  coral: "FF7F50",
  cornflowerblue: "6495ED",
  cornsilk: "FFF8DC",
  crimson: "DC143C",
  cyan: "00FFFF",
  darkblue: "00008B",
  darkcyan: "008B8B",
  darkgoldenrod: "B8860B",
  darkgray: "A9A9A9",
  darkgreen: "006400",
  darkgrey: "A9A9A9",
  darkkhaki: "BDB76B",
  darkmagenta: "8B008B",
  darkolivegreen: "556B2F",
  darkorange: "FF8C00",
  darkorchid: "9932CC",
  darkred: "8B0000",
  darksalmon: "E9967A",
  darkseagreen: "8FBC8F",
  darkslateblue: "483D8B",
  darkslategray: "2F4F4F",
  darkslategrey: "2F4F4F",
  darkturquoise: "00CED1",
  darkviolet: "9400D3",
  deeppink: "FF1493",
  deepskyblue: "00BFFF",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1E90FF",
  firebrick: "B22222",
  floralwhite: "FFFAF0",
  forestgreen: "228B22",
  fuchsia: "FF00FF",
  gainsboro: "DCDCDC",
  ghostwhite: "F8F8FF",
  gold: "FFD700",
  goldenrod: "DAA520",
  gray: "808080",
  green: "008000",
  greenyellow: "ADFF2F",
  grey: "808080",
  honeydew: "F0FFF0",
  hotpink: "FF69B4",
  indianred: "CD5C5C",
  indigo: "4B0082",
  ivory: "FFFFF0",
  khaki: "F0E68C",
  lavender: "E6E6FA",
  lavenderblush: "FFF0F5",
  lawngreen: "7CFC00",
  lemonchiffon: "FFFACD",
  lightblue: "ADD8E6",
  lightcoral: "F08080",
  lightcyan: "E0FFFF",
  lightgoldenrodyellow: "FAFAD2",
  lightgray: "D3D3D3",
  lightgreen: "90EE90",
  lightgrey: "D3D3D3",
  lightpink: "FFB6C1",
  lightsalmon: "FFA07A",
  lightseagreen: "20B2AA",
  lightskyblue: "87CEFA",
  lightslategray: "778899",
  lightslategrey: "778899",
  lightsteelblue: "B0C4DE",
  lightyellow: "FFFFE0",
  lime: "00FF00",
  limegreen: "32CD32",
  linen: "FAF0E6",
  magenta: "FF00FF",
  maroon: "800000",
  mediumaquamarine: "66CDAA",
  mediumblue: "0000CD",
  mediumorchid: "BA55D3",
  mediumpurple: "9370DB",
  mediumseagreen: "3CB371",
  mediumslateblue: "7B68EE",
  mediumspringgreen: "00FA9A",
  mediumturquoise: "48D1CC",
  mediumvioletred: "C71585",
  midnightblue: "191970",
  mintcream: "F5FFFA",
  mistyrose: "FFE4E1",
  moccasin: "FFE4B5",
  navajowhite: "FFDEAD",
  navy: "000080",
  oldlace: "FDF5E6",
  olive: "808000",
  olivedrab: "6B8E23",
  orange: "FFA500",
  orangered: "FF4500",
  orchid: "DA70D6",
  palegoldenrod: "EEE8AA",
  palegreen: "98FB98",
  paleturquoise: "AFEEEE",
  palevioletred: "DB7093",
  papayawhip: "FFEFD5",
  peachpuff: "FFDAB9",
  peru: "CD853F",
  pink: "FFC0CB",
  plum: "DDA0DD",
  powderblue: "B0E0E6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "FF0000",
  rosybrown: "BC8F8F",
  royalblue: "4169E1",
  saddlebrown: "8B4513",
  salmon: "FA8072",
  sandybrown: "F4A460",
  seagreen: "2E8B57",
  seashell: "FFF5EE",
  sienna: "A0522D",
  silver: "C0C0C0",
  skyblue: "87CEEB",
  slateblue: "6A5ACD",
  slategray: "708090",
  slategrey: "708090",
  snow: "FFFAFA",
  springgreen: "00FF7F",
  steelblue: "4682B4",
  tan: "D2B48C",
  teal: "008080",
  thistle: "D8BFD8",
  tomato: "FF6347",
  turquoise: "40E0D0",
  violet: "EE82EE",
  wheat: "F5DEB3",
  white: "FFFFFF",
  whitesmoke: "F5F5F5",
  yellow: "FFFF00",
  yellowgreen: "9ACD32"
};

// node_modules/@create-figma-plugin/utilities/lib/color/convert-named-color-to-hex-color.js
function convertNamedColorToHexColor(namedColor) {
  const hexColor = NAMED_COLORS[namedColor.toLowerCase()];
  if (typeof hexColor === "undefined") {
    return null;
  }
  return hexColor;
}

// node_modules/rgb-hex/index.js
var toHex = (red, green, blue, alpha) => (blue | green << 8 | red << 16 | 1 << 24).toString(16).slice(1) + alpha;
function rgbHex(red, green, blue, alpha) {
  let isPercent = (red + (alpha || "")).toString().includes("%");
  if (typeof red === "string" && !green) {
    const parsed = parseCssRgbString(red);
    if (!parsed) {
      throw new TypeError("Invalid or unsupported color format.");
    }
    isPercent = false;
    [red, green, blue, alpha] = parsed;
  } else if (alpha !== void 0) {
    alpha = Number.parseFloat(alpha);
  }
  if (typeof red !== "number" || typeof green !== "number" || typeof blue !== "number" || red > 255 || green > 255 || blue > 255) {
    throw new TypeError("Expected three numbers below 256");
  }
  if (typeof alpha === "number") {
    if (!isPercent && alpha >= 0 && alpha <= 1) {
      alpha = Math.round(255 * alpha);
    } else if (isPercent && alpha >= 0 && alpha <= 100) {
      alpha = Math.round(255 * alpha / 100);
    } else {
      throw new TypeError(`Expected alpha value (${alpha}) as a fraction or percentage`);
    }
    alpha = (alpha | 1 << 8).toString(16).slice(1);
  } else {
    alpha = "";
  }
  return toHex(red, green, blue, alpha);
}
var parseCssRgbString = (input) => {
  const parts = input.replace(/rgba?\(([^)]+)\)/, "$1").split(/[,\s/]+/).filter(Boolean);
  if (parts.length < 3) {
    return;
  }
  const parseValue = (value2, max) => {
    value2 = value2.trim();
    if (value2.endsWith("%")) {
      return Math.min(Number.parseFloat(value2) * max / 100, max);
    }
    return Math.min(Number.parseFloat(value2), max);
  };
  const red = parseValue(parts[0], 255);
  const green = parseValue(parts[1], 255);
  const blue = parseValue(parts[2], 255);
  let alpha;
  if (parts.length === 4) {
    alpha = parseValue(parts[3], 1);
  }
  return [red, green, blue, alpha];
};

// node_modules/@create-figma-plugin/utilities/lib/color/convert-rgb-color-to-hex-color.js
function convertRgbColorToHexColor(rgbColor) {
  const { r, g, b } = rgbColor;
  if (r < 0 || r > 1 || g < 0 || g > 1 || b < 0 || b > 1) {
    return null;
  }
  try {
    return rgbHex(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)).toUpperCase();
  } catch {
    return null;
  }
}

// node_modules/@create-figma-plugin/utilities/lib/color/is-valid-hex-color.js
function isValidHexColor(hexColor) {
  return convertHexColorToRgbColor(hexColor) !== null;
}

// node_modules/@create-figma-plugin/utilities/lib/events.js
var eventHandlers = {};
var currentId = 0;
function on(name, handler) {
  const id = `${currentId}`;
  currentId += 1;
  eventHandlers[id] = { handler, name };
  return function() {
    delete eventHandlers[id];
  };
}
function once(name, handler) {
  let done = false;
  return on(name, function(...args) {
    if (done === true) {
      return;
    }
    done = true;
    handler(...args);
  });
}
var emit = typeof window === "undefined" ? function(name, ...args) {
  figma.ui.postMessage([name, ...args]);
} : function(name, ...args) {
  window.parent.postMessage({
    pluginMessage: [name, ...args]
  }, "*");
};
function invokeEventHandler(name, args) {
  let invoked = false;
  for (const id in eventHandlers) {
    if (eventHandlers[id].name === name) {
      eventHandlers[id].handler.apply(null, args);
      invoked = true;
    }
  }
  if (invoked === false) {
    throw new Error(`No event handler with name \`${name}\``);
  }
}
if (typeof window === "undefined") {
  figma.ui.onmessage = function(args) {
    if (!Array.isArray(args)) {
      return;
    }
    const [name, ...rest] = args;
    if (typeof name !== "string") {
      return;
    }
    invokeEventHandler(name, rest);
  };
} else {
  window.onmessage = function(event) {
    if (typeof event.data.pluginMessage === "undefined") {
      return;
    }
    const args = event.data.pluginMessage;
    if (!Array.isArray(args)) {
      return;
    }
    const [name, ...rest] = event.data.pluginMessage;
    if (typeof name !== "string") {
      return;
    }
    invokeEventHandler(name, rest);
  };
}

// node_modules/@create-figma-plugin/utilities/lib/function/ensure-minimum-time.js
function ensureMinimumTime(minimumTime, callback) {
  return async function(...args) {
    const startTimestamp = Date.now();
    const result = await callback(...args);
    const elapsedTime = Date.now() - startTimestamp;
    if (elapsedTime >= minimumTime) {
      return result;
    }
    return new Promise(function(resolve) {
      setTimeout(function() {
        resolve(result);
      }, minimumTime - elapsedTime);
    });
  };
}

// node_modules/@create-figma-plugin/utilities/lib/image/create-canvas-element-from-image-element.js
async function createCanvasElementFromImageElement(imageElement) {
  const canvasElement = document.createElement("canvas");
  canvasElement.width = imageElement.width;
  canvasElement.height = imageElement.height;
  const context = canvasElement.getContext("2d");
  context.drawImage(imageElement, 0, 0);
  return canvasElement;
}

// node_modules/@create-figma-plugin/utilities/lib/image/create-image-element-from-blob-async.js
async function createImageElementFromBlobAsync(blob) {
  return new Promise(function(resolve, reject) {
    const imageElement = new Image();
    imageElement.onload = function() {
      resolve(imageElement);
    };
    imageElement.onerror = reject;
    imageElement.src = URL.createObjectURL(blob);
  });
}

// node_modules/@create-figma-plugin/utilities/lib/image/create-canvas-element-from-blob-async.js
async function createCanvasElementFromBlobAsync(blob) {
  const imageElement = await createImageElementFromBlobAsync(blob);
  return createCanvasElementFromImageElement(imageElement);
}

// node_modules/@create-figma-plugin/utilities/lib/image/create-image-element-from-bytes-async.js
async function createImageElementFromBytesAsync(bytes) {
  return createImageElementFromBlobAsync(new Blob([bytes]));
}

// node_modules/@create-figma-plugin/utilities/lib/image/create-canvas-element-from-bytes-async.js
async function createCanvasElementFromBytesAsync(bytes) {
  const imageElement = await createImageElementFromBytesAsync(bytes);
  return createCanvasElementFromImageElement(imageElement);
}

// node_modules/@create-figma-plugin/utilities/lib/image/create-image-paint.js
function createImagePaint(bytes) {
  const image = figma.createImage(bytes);
  return {
    imageHash: image.hash,
    scaleMode: "FILL",
    scalingFactor: 0.5,
    type: "IMAGE"
  };
}

// node_modules/@create-figma-plugin/utilities/lib/image/read-bytes-from-canvas-element-async.js
async function readBytesFromCanvasElementAsync(canvasElement) {
  return new Promise(function(resolve, reject) {
    canvasElement.toBlob(function(blob) {
      const reader = new FileReader();
      reader.onload = function() {
        resolve(new Uint8Array(reader.result));
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(blob);
    });
  });
}

// node_modules/@create-figma-plugin/utilities/lib/mixed-values.js
var MIXED_BOOLEAN = null;
var MIXED_NUMBER = 999999999999999;
var MIXED_STRING = "999999999999999";

// node_modules/@create-figma-plugin/utilities/lib/monetization/document-use-count.js
var DEFAULT_KEY = "documentUseCount";
function getDocumentUseCount(key = DEFAULT_KEY) {
  const value2 = figma.root.getPluginData(key);
  if (value2 === "") {
    return 0;
  }
  const pluginData = JSON.parse(value2);
  return pluginData.useCount;
}
function incrementDocumentUseCount(key = DEFAULT_KEY) {
  const useCount = getDocumentUseCount(key);
  const pluginData = {
    useCount: useCount + 1
  };
  figma.root.setPluginData(key, JSON.stringify(pluginData));
  return pluginData.useCount;
}
function resetDocumentUseCount(key = DEFAULT_KEY) {
  const pluginData = {
    useCount: 0
  };
  figma.root.setPluginData(key, JSON.stringify(pluginData));
}

// node_modules/@create-figma-plugin/utilities/lib/monetization/total-use-count.js
var DEFAULT_KEY2 = "totalUseCount";
async function getTotalUseCountAsync(key = DEFAULT_KEY2) {
  const useCount = await figma.clientStorage.getAsync(key);
  if (typeof useCount === "undefined") {
    return 0;
  }
  return useCount;
}
async function incrementTotalUseCountAsync(key = DEFAULT_KEY2) {
  const useCount = await getTotalUseCountAsync(key);
  const newUseCount = useCount + 1;
  await figma.clientStorage.setAsync(key, newUseCount);
  return newUseCount;
}
async function resetTotalUseCountAsync(key = DEFAULT_KEY2) {
  await figma.clientStorage.setAsync(key, 0);
}

// node_modules/@create-figma-plugin/utilities/lib/node/absolute-position/get-absolute-position.js
function getAbsolutePosition(node) {
  return {
    x: node.absoluteTransform[0][2],
    y: node.absoluteTransform[1][2]
  };
}

// node_modules/@create-figma-plugin/utilities/lib/node/absolute-position/set-absolute-position.js
function setAbsolutePosition(node, vector) {
  if (typeof vector.x === "undefined" && typeof vector.y === "undefined") {
    throw new Error("Need at least one of `x` or `y`");
  }
  let x = typeof vector.x === "undefined" ? null : vector.x;
  let y = typeof vector.y === "undefined" ? null : vector.y;
  let parentNode = node.parent;
  while (parentNode !== null && parentNode.type !== "PAGE") {
    if (parentNode.type === "FRAME" || parentNode.type === "SECTION") {
      if (x !== null) {
        x = x - parentNode.x;
      }
      if (y !== null) {
        y = y - parentNode.y;
      }
    }
    parentNode = parentNode.parent;
  }
  if (x !== null) {
    node.x = x;
  }
  if (y !== null) {
    node.y = y;
  }
}

// node_modules/@create-figma-plugin/utilities/lib/node/traverse-node.js
function traverseNode(node, processNode, stopTraversal) {
  if (node.removed === true) {
    return;
  }
  if ("children" in node && (typeof stopTraversal !== "function" || stopTraversal(node) === false)) {
    for (const childNode of node.children) {
      traverseNode(childNode, processNode, stopTraversal);
    }
  }
  processNode(node);
}

// node_modules/@create-figma-plugin/utilities/lib/node/collapse-layer.js
function collapseLayer(node) {
  let didChange = false;
  traverseNode(node, function(node2) {
    if ("expanded" in node2 && node2.expanded === true) {
      node2.expanded = false;
      didChange = true;
    }
  });
  return didChange;
}

// node_modules/@create-figma-plugin/utilities/lib/node/get-nodes/get-parent-node.js
function getParentNode(node) {
  const parentNode = node.parent;
  if (parentNode === null) {
    throw new Error(`\`node.parent\` is \`null\``);
  }
  return parentNode;
}

// node_modules/@create-figma-plugin/utilities/lib/node/compute-bounding-box.js
function computeBoundingBox(node) {
  if ("rotation" in node && node.rotation === 0) {
    const absolutePosition2 = getAbsolutePosition(node);
    const { width: width2, height: height2 } = node;
    return { ...absolutePosition2, height: height2, width: width2 };
  }
  const parentNode = getParentNode(node);
  const index = parentNode.children.indexOf(node);
  const group = figma.group([node], parentNode, index);
  const absolutePosition = getAbsolutePosition(group);
  const { width, height } = group;
  parentNode.insertChild(index, node);
  return { ...absolutePosition, height, width };
}

// node_modules/@create-figma-plugin/utilities/lib/node/compute-maximum-bounds.js
function computeMaximumBounds(nodes) {
  let maximumBounds = [
    {
      x: Number.MAX_VALUE,
      y: Number.MAX_VALUE
    },
    {
      x: -1 * Number.MAX_VALUE,
      y: -1 * Number.MAX_VALUE
    }
  ];
  for (const node of nodes) {
    const { x, y, width, height } = computeBoundingBox(node);
    maximumBounds = [
      {
        x: Math.min(maximumBounds[0].x, x),
        y: Math.min(maximumBounds[0].y, y)
      },
      {
        x: Math.max(maximumBounds[1].x, x + width),
        y: Math.max(maximumBounds[1].y, y + height)
      }
    ];
  }
  return maximumBounds;
}

// node_modules/@create-figma-plugin/utilities/lib/node/deduplicate-nodes.js
function deduplicateNodes(nodes) {
  const result = {};
  for (const node of nodes) {
    result[node.id] = node;
  }
  return Object.values(result);
}

// node_modules/@create-figma-plugin/utilities/lib/node/get-node-index-path.js
function getNodeIndexPath(node) {
  const parentNode = node.parent;
  if (parentNode === null) {
    throw new Error("`parentNode` is `null`");
  }
  const nodeIndex = parentNode.children.findIndex(function(childNode) {
    return childNode.id === node.id;
  });
  if (nodeIndex === -1 || parentNode.type === "DOCUMENT") {
    throw new Error("Invariant violation");
  }
  if (parentNode.type === "PAGE") {
    const pageIndex = figma.root.children.findIndex(function(pageNode) {
      return pageNode.id === parentNode.id;
    });
    if (pageIndex === -1) {
      throw new Error("Invariant violation");
    }
    return [pageIndex, nodeIndex];
  }
  return [...getNodeIndexPath(parentNode), nodeIndex];
}

// node_modules/@create-figma-plugin/utilities/lib/node/get-nodes/get-document-components.js
function getDocumentComponents() {
  const result = [];
  for (const page of figma.root.children) {
    for (const node of page.children) {
      traverseNode(node, function(node2) {
        if (node2.type === "COMPONENT") {
          result.push(node2);
        }
      }, function(node2) {
        return node2.type === "COMPONENT";
      });
    }
  }
  return result;
}

// node_modules/@create-figma-plugin/utilities/lib/node/get-nodes/get-scene-node-by-id.js
function getSceneNodeById(id) {
  const node = figma.getNodeById(id);
  if (node === null) {
    throw new Error(`No node found with \`id\`: ${id}`);
  }
  if (node.type === "DOCUMENT" || node.type === "PAGE") {
    throw new Error("`node` is not a `SceneNode`");
  }
  return node;
}

// node_modules/@create-figma-plugin/utilities/lib/node/get-nodes/get-selected-nodes-or-all-nodes.js
function getSelectedNodesOrAllNodes() {
  const selectedNodes = figma.currentPage.selection;
  if (selectedNodes.length > 0) {
    return selectedNodes.slice();
  }
  return figma.currentPage.children.slice();
}

// node_modules/@create-figma-plugin/utilities/lib/node/insert-node/insert-after-node.js
function insertAfterNode(node, referenceNode) {
  const parentNode = getParentNode(referenceNode);
  const index = parentNode.children.indexOf(referenceNode);
  parentNode.insertChild(index, node);
}

// node_modules/@create-figma-plugin/utilities/lib/node/insert-node/insert-before-node.js
function insertBeforeNode(node, referenceNode) {
  const parentNode = getParentNode(referenceNode);
  const index = parentNode.children.indexOf(referenceNode);
  parentNode.insertChild(index + 1, node);
}

// node_modules/@create-figma-plugin/utilities/lib/node/is-locked.js
function isLocked(node) {
  if (node.locked === true) {
    return true;
  }
  if (node.parent === null || node.parent.type === "PAGE") {
    return false;
  }
  return isLocked(node.parent);
}

// node_modules/@create-figma-plugin/utilities/lib/node/is-visible.js
function isVisible(node) {
  if (node.visible === false) {
    return false;
  }
  if (node.parent === null || node.parent.type === "PAGE") {
    return true;
  }
  return isVisible(node.parent);
}

// node_modules/@create-figma-plugin/utilities/lib/node/is-within-instance-node.js
function isWithinInstanceNode(node) {
  const parentNode = node.parent;
  if (parentNode === null || parentNode.type === "DOCUMENT" || parentNode.type === "PAGE") {
    return false;
  }
  if (parentNode.type === "INSTANCE") {
    return true;
  }
  return isWithinInstanceNode(parentNode);
}

// node_modules/@create-figma-plugin/utilities/lib/node/load-fonts-async.js
async function loadFontsAsync(nodes) {
  const result = {};
  for (const node of nodes) {
    switch (node.type) {
      case "CONNECTOR":
      case "SHAPE_WITH_TEXT":
      case "STICKY": {
        collectFontsUsedInNode(node.text, result);
        break;
      }
      case "TEXT": {
        collectFontsUsedInNode(node, result);
        break;
      }
    }
  }
  await Promise.all(Object.values(result).map(function(font) {
    return figma.loadFontAsync(font);
  }));
}
function collectFontsUsedInNode(node, result) {
  const length = node.characters.length;
  if (length === 0) {
    const fontName = node.fontName;
    const key = createKey(fontName);
    if (key in result) {
      return;
    }
    result[key] = fontName;
    return;
  }
  let i = -1;
  while (++i < length) {
    const fontName = node.getRangeFontName(i, i + 1);
    const key = createKey(fontName);
    if (key in result) {
      continue;
    }
    result[key] = fontName;
  }
}
function createKey(fontName) {
  return `${fontName.family}-${fontName.style}`;
}

// node_modules/@create-figma-plugin/utilities/lib/node/relaunch-button/private/update-relaunch-buttons-data.js
var RELAUNCH_BUTTONS_PLUGIN_DATA_KEY = "relaunchButtons";
function getRelaunchButtonsData(node) {
  const pluginData = node.getPluginData(RELAUNCH_BUTTONS_PLUGIN_DATA_KEY);
  if (pluginData === "") {
    return {};
  }
  return JSON.parse(pluginData);
}
function setRelaunchButtonsData(node, relaunchButtonsData) {
  if (Object.keys(relaunchButtonsData).length === 0) {
    node.setPluginData(RELAUNCH_BUTTONS_PLUGIN_DATA_KEY, "");
    return;
  }
  node.setPluginData(RELAUNCH_BUTTONS_PLUGIN_DATA_KEY, JSON.stringify(relaunchButtonsData));
}

// node_modules/@create-figma-plugin/utilities/lib/node/relaunch-button/set-relaunch-button.js
function setRelaunchButton(node, relaunchButtonId, options = { description: "" }) {
  const relaunchButtonsData = {
    ...getRelaunchButtonsData(node),
    [relaunchButtonId]: options.description
  };
  setRelaunchButtonsData(node, relaunchButtonsData);
  node.setRelaunchData(relaunchButtonsData);
}

// node_modules/@create-figma-plugin/utilities/lib/node/relaunch-button/unset-relaunch-button.js
function unsetRelaunchButton(node, relaunchButtonId) {
  if (typeof relaunchButtonId === "undefined") {
    setRelaunchButtonsData(node, {});
    node.setRelaunchData({});
    return;
  }
  const relaunchButtonsData = getRelaunchButtonsData(node);
  if (typeof relaunchButtonsData[relaunchButtonId] !== "undefined") {
    delete relaunchButtonsData[relaunchButtonId];
  }
  setRelaunchButtonsData(node, relaunchButtonsData);
  node.setRelaunchData(relaunchButtonsData);
}

// node_modules/@create-figma-plugin/utilities/lib/node/sibling-nodes/are-sibling-nodes.js
function areSiblingNodes(nodes) {
  if (nodes.length < 2) {
    return true;
  }
  const [firstNode, ...rest] = nodes;
  const firstParentNode = getParentNode(firstNode);
  for (const node of rest) {
    if (node.parent === null || node.parent.id !== firstParentNode.id) {
      return false;
    }
  }
  return true;
}

// node_modules/@create-figma-plugin/utilities/lib/node/sibling-nodes/compute-sibling-nodes.js
function computeSiblingNodes(nodes) {
  const groups = resolveGroups(nodes);
  const result = [];
  for (const group of groups) {
    const parentNode = getParentNode(group[0]);
    const siblingNodes = group.map(function(node) {
      return {
        index: parentNode.children.indexOf(node),
        node
      };
    }).sort(function(a, b) {
      return a.index - b.index;
    }).map(function({ node }) {
      return node;
    });
    result.push(siblingNodes);
  }
  return result;
}
function resolveGroups(nodes) {
  const result = {};
  for (const node of nodes) {
    const parentNode = getParentNode(node);
    const parentId = parentNode.id;
    if (parentId in result === false) {
      result[parentId] = [];
    }
    result[parentId].push(node);
  }
  return Object.values(result);
}

// node_modules/@create-figma-plugin/utilities/lib/node/sort-nodes/sort-nodes-by-canonical-order.js
function sortNodesByCanonicalOrder(siblingNodes) {
  if (siblingNodes.length < 2) {
    return siblingNodes.slice();
  }
  const parentNode = getParentNode(siblingNodes[0]);
  if (areSiblingNodes(siblingNodes) === false) {
    throw new Error("Nodes in `siblingNodes` do not have the same parent");
  }
  const result = siblingNodes.slice().map(function(node) {
    return {
      index: parentNode.children.indexOf(node),
      node
    };
  }).sort(function(a, b) {
    return a.index - b.index;
  }).map(function({ node }) {
    return node;
  });
  if ("layoutMode" in parentNode && parentNode.layoutMode !== "NONE") {
    return result;
  }
  return result.reverse();
}

// node_modules/@create-figma-plugin/utilities/lib/node/sort-nodes/sort-nodes-by-name.js
var import_natural_compare_lite = __toESM(require_natural_compare_lite(), 1);
function sortNodesByName(nodes) {
  if (nodes.length < 2) {
    return nodes.slice();
  }
  return nodes.slice().sort(function(a, b) {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    if (aName !== bName) {
      return (0, import_natural_compare_lite.default)(bName, aName);
    }
    const y = b.y - a.y;
    if (y !== 0) {
      return y;
    }
    const x = b.x - a.x;
    if (x !== 0) {
      return x;
    }
    return (0, import_natural_compare_lite.default)(b.id, a.id);
  });
}

// node_modules/@create-figma-plugin/utilities/lib/object/compare-string-arrays.js
function compareStringArrays(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (const index in a) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}

// node_modules/@create-figma-plugin/utilities/lib/node/sort-nodes/update-nodes-sort-order.js
function updateNodesSortOrder(siblingNodes) {
  const parentNode = getParentNode(siblingNodes[0]);
  if (areSiblingNodes(siblingNodes) === false) {
    throw new Error("Nodes in `siblingNodes` do not have the same parent");
  }
  const siblingNodesCopy = siblingNodes.slice();
  if ("layoutMode" in parentNode && parentNode.layoutMode !== "NONE") {
    siblingNodesCopy.reverse();
  }
  const idsBefore = parentNode.children.map(function({ id }) {
    return id;
  });
  const insertIndex = computeInsertIndex(siblingNodesCopy, idsBefore);
  for (const node of siblingNodesCopy) {
    parentNode.insertChild(insertIndex, node);
  }
  const idsAfter = parentNode.children.map(function({ id }) {
    return id;
  });
  return compareStringArrays(idsBefore, idsAfter) === false;
}
function computeInsertIndex(nodes, ids) {
  let insertIndex = -1;
  for (const node of nodes) {
    const index = ids.indexOf(node.id);
    if (index > insertIndex) {
      insertIndex = index;
    }
  }
  return insertIndex + 1;
}

// node_modules/@create-figma-plugin/utilities/lib/node/traverse-node-async.js
async function traverseNodeAsync(node, processNodeAsync, stopTraversalAsync) {
  if (node.removed === true) {
    return;
  }
  if ("children" in node && (typeof stopTraversalAsync !== "function" || await stopTraversalAsync(node) === false)) {
    for (const childNode of node.children) {
      await traverseNodeAsync(childNode, processNodeAsync, stopTraversalAsync);
    }
  }
  await processNodeAsync(node);
}

// node_modules/@create-figma-plugin/utilities/lib/number/private/regex.js
var floatOperandRegex = /^-?\d*(?:\.\d*)?$/;
var integerOperandRegex = /^-?\d*$/;
var operatorRegex = /[+\-*/]/;
var operatorSuffixRegex = /[+\-*/]$/;
var numbersRegex = /\d/;
var invalidCharactersRegex = /[^\d.+\-*/]/;

// node_modules/@create-figma-plugin/utilities/lib/number/evaluate-numeric-expression.js
function evaluateNumericExpression(value) {
  if (value === "" || numbersRegex.test(value) === false || invalidCharactersRegex.test(value) === true) {
    return null;
  }
  if (operatorRegex.test(value) === true) {
    if (operatorSuffixRegex.test(value) === true) {
      return eval(value.substring(0, value.length - 1));
    }
    return eval(value);
  }
  return parseFloat(value);
}

// node_modules/@create-figma-plugin/utilities/lib/number/is-valid-numeric-input.js
function isValidNumericInput(value2, options = { integersOnly: false }) {
  const split = (value2[0] === "-" ? value2.substring(1) : value2).split(operatorRegex);
  let i = -1;
  while (++i < split.length) {
    const operand = split[i];
    if (operand === "" && i !== split.length - 1 || (options.integersOnly === true ? integerOperandRegex : floatOperandRegex).test(operand) === false) {
      return false;
    }
  }
  return true;
}

// node_modules/@create-figma-plugin/utilities/lib/object/clone-object.js
function cloneObject(object) {
  if (object === null || typeof object === "undefined" || typeof object === "boolean" || typeof object === "number" || typeof object === "string") {
    return object;
  }
  if (Array.isArray(object)) {
    const result2 = [];
    for (const value2 of object) {
      result2.push(cloneObject(value2));
    }
    return result2;
  }
  const result = {};
  for (const key in object) {
    result[key] = cloneObject(object[key]);
  }
  return result;
}

// node_modules/@create-figma-plugin/utilities/lib/object/compare-objects.js
function compareObjects(a, b) {
  if (a === null || typeof a === "undefined" || typeof a === "boolean" || typeof a === "number" || typeof a === "string") {
    return a === b;
  }
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (const index in a) {
      if (compareObjects(a[index], b[index]) === false) {
        return false;
      }
    }
    return true;
  }
  if (b === null || typeof b === "undefined" || typeof b === "boolean" || typeof b === "number" || typeof b === "string" || Array.isArray(b)) {
    return false;
  }
  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (compareObjects(a[key], b[key]) === false) {
      return false;
    }
  }
  return true;
}

// node_modules/@create-figma-plugin/utilities/lib/object/deduplicate-array.js
function deduplicateArray(array) {
  const object = {};
  const result = [];
  for (const value2 of array) {
    if (object[`${value2}`] === true) {
      continue;
    }
    object[`${value2}`] = true;
    result.push(value2);
  }
  return result;
}

// node_modules/@create-figma-plugin/utilities/lib/object/extract-attributes.js
function extractAttributes(array, attributes) {
  const result = [];
  for (const object of array) {
    result.push(pick(object, attributes));
  }
  return result;
}
function pick(object, keys) {
  const result = {};
  for (const key of keys) {
    const value2 = object[key];
    if (typeof value2 === "undefined") {
      throw new Error(`Key \`${String(key)}\` does not exist on \`object\``);
    }
    result[key] = value2;
  }
  return result;
}

// node_modules/@create-figma-plugin/utilities/lib/settings.js
var DEFAULT_SETTINGS_KEY = "settings";
async function loadSettingsAsync(defaultSettings, settingsKey = DEFAULT_SETTINGS_KEY) {
  const settings = await figma.clientStorage.getAsync(settingsKey);
  if (typeof settings === "undefined") {
    return defaultSettings;
  }
  return Object.assign({}, defaultSettings, settings);
}
async function saveSettingsAsync(settings, settingsKey = DEFAULT_SETTINGS_KEY) {
  await figma.clientStorage.setAsync(settingsKey, settings);
}

// node_modules/@create-figma-plugin/utilities/lib/string/format-message.js
var CHECK = "✔";
var CROSS = "✘";
var WARNING = "⚠";
var SPACE = " ";
function formatSuccessMessage(message) {
  return `${CHECK} ${SPACE} ${message}`;
}
function formatErrorMessage(message) {
  return `${CROSS} ${SPACE} ${message}`;
}
function formatWarningMessage(message) {
  return `${WARNING} ${SPACE} ${message}`;
}

// node_modules/@create-figma-plugin/utilities/lib/string/pluralize.js
function pluralize(number, singular, plural) {
  if (number === 1) {
    return singular;
  }
  return typeof plural === "undefined" ? `${singular}s` : plural;
}

// node_modules/@create-figma-plugin/utilities/lib/ui.js
function showUI(options, data) {
  if (typeof __html__ === "undefined") {
    throw new Error("No UI defined");
  }
  const html = `<div id="create-figma-plugin"></div><script>document.body.classList.add('theme-${figma.editorType}');const __FIGMA_COMMAND__='${typeof figma.command === "undefined" ? "" : figma.command}';const __SHOW_UI_DATA__=${JSON.stringify(typeof data === "undefined" ? {} : data)};${__html__}<\/script>`;
  figma.showUI(html, {
    ...options,
    themeColors: typeof options.themeColors === "undefined" ? true : options.themeColors
  });
}

export {
  convertHexColorToRgbColor,
  convertNamedColorToHexColor,
  convertRgbColorToHexColor,
  isValidHexColor,
  on,
  once,
  emit,
  ensureMinimumTime,
  createCanvasElementFromImageElement,
  createImageElementFromBlobAsync,
  createCanvasElementFromBlobAsync,
  createImageElementFromBytesAsync,
  createCanvasElementFromBytesAsync,
  createImagePaint,
  readBytesFromCanvasElementAsync,
  MIXED_BOOLEAN,
  MIXED_NUMBER,
  MIXED_STRING,
  getDocumentUseCount,
  incrementDocumentUseCount,
  resetDocumentUseCount,
  getTotalUseCountAsync,
  incrementTotalUseCountAsync,
  resetTotalUseCountAsync,
  getAbsolutePosition,
  setAbsolutePosition,
  traverseNode,
  collapseLayer,
  getParentNode,
  computeBoundingBox,
  computeMaximumBounds,
  deduplicateNodes,
  getNodeIndexPath,
  getDocumentComponents,
  getSceneNodeById,
  getSelectedNodesOrAllNodes,
  insertAfterNode,
  insertBeforeNode,
  isLocked,
  isVisible,
  isWithinInstanceNode,
  loadFontsAsync,
  setRelaunchButton,
  unsetRelaunchButton,
  areSiblingNodes,
  computeSiblingNodes,
  sortNodesByCanonicalOrder,
  sortNodesByName,
  compareStringArrays,
  updateNodesSortOrder,
  traverseNodeAsync,
  evaluateNumericExpression,
  isValidNumericInput,
  cloneObject,
  compareObjects,
  deduplicateArray,
  extractAttributes,
  loadSettingsAsync,
  saveSettingsAsync,
  formatSuccessMessage,
  formatErrorMessage,
  formatWarningMessage,
  pluralize,
  showUI
};
/*! Bundled license information:

natural-compare-lite/index.js:
  (*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   *)
*/
//# sourceMappingURL=chunk-SXSV4L3C.js.map
